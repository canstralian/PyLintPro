#!/usr/bin/env python3
"""
Health report generator for Mendicant AI.
Generates comprehensive health reports for repositories.
"""

import argparse
import asyncio
import json
import sys
from pathlib import Path
from typing import Dict, Any

# Add src to path for imports
sys.path.append(str(Path(__file__).parent.parent / 'src'))

from src.utils import setup_logging
from analyze_repo import RepositoryAnalyzer

logger = setup_logging(__name__)

class HealthReportGenerator:
    """Generate detailed health reports for repositories."""
    
    def __init__(self):
        self.template = """
# Repository Health Report

## Executive Summary

**Repository:** {repository}  
**Health Score:** {health_score}/100  
**Analysis Date:** {timestamp}  

{summary_text}

## Detailed Findings

{detailed_findings}

## Recommendations

{recommendations}

## Metrics Summary

{metrics_table}

---

*Generated by Mendicant AI - Self-Healing Repositories*  
*For more information, visit [mendicant.ai](https://github.com/canstralian/PyLintPro)*
"""
    
    async def generate_report(
        self, 
        repo_path: str, 
        output_format: str = "markdown"
    ) -> str:
        """Generate a comprehensive health report."""
        
        # Run analysis
        analyzer = RepositoryAnalyzer(Path(repo_path))
        results = await analyzer.analyze()
        
        # Generate report sections
        summary_text = self._generate_summary(results)
        detailed_findings = self._generate_detailed_findings(results)
        recommendations = self._generate_recommendations_section(results)
        metrics_table = self._generate_metrics_table(results)
        
        # Fill template
        report = self.template.format(
            repository=results["repository"],
            health_score=results["health_score"],
            timestamp=self._get_timestamp(),
            summary_text=summary_text,
            detailed_findings=detailed_findings,
            recommendations=recommendations,
            metrics_table=metrics_table
        )
        
        return report
    
    def _generate_summary(self, results: Dict[str, Any]) -> str:
        """Generate executive summary."""
        score = results["health_score"]
        
        if score >= 90:
            status = "🟢 **Excellent** - Repository is in great health"
        elif score >= 70:
            status = "🟡 **Good** - Minor issues need attention"
        elif score >= 50:
            status = "🟠 **Fair** - Several improvements needed"
        else:
            status = "🔴 **Poor** - Significant issues require immediate attention"
        
        summary = f"""**Overall Status:** {status}

This repository has been analyzed across {len(results['checks'])} categories. """
        
        # Add category highlights
        for category, stats in results["summary"].items():
            if stats["failed"] > 0:
                summary += f"\n- **{category.title()}**: {stats['failed']} critical issues found"
            elif stats["warnings"] > 0:
                summary += f"\n- **{category.title()}**: {stats['warnings']} minor issues found"
            else:
                summary += f"\n- **{category.title()}**: ✅ All checks passed"
        
        return summary
    
    def _generate_detailed_findings(self, results: Dict[str, Any]) -> str:
        """Generate detailed findings section."""
        findings = ""
        
        for category, checks in results["checks"].items():
            findings += f"\n### {category.replace('_', ' ').title()}\n\n"
            
            failed_checks = [c for c in checks if c["status"] == "failed"]
            warning_checks = [c for c in checks if c["status"] == "warning"]
            passed_checks = [c for c in checks if c["status"] == "passed"]
            
            if failed_checks:
                findings += "**Critical Issues:**\n"
                for check in failed_checks[:5]:  # Limit to 5 for readability
                    findings += f"- ❌ {check['message']}"
                    if check.get('file_path'):
                        findings += f" ({check['file_path']}"
                        if check.get('line_number'):
                            findings += f":{check['line_number']}"
                        findings += ")"
                    findings += "\n"
                
                if len(failed_checks) > 5:
                    findings += f"- ... and {len(failed_checks) - 5} more issues\n"
                
                findings += "\n"
            
            if warning_checks:
                findings += "**Minor Issues:**\n"
                for check in warning_checks[:3]:  # Limit warnings
                    findings += f"- ⚠️ {check['message']}"
                    if check.get('file_path'):
                        findings += f" ({check['file_path']})"
                    findings += "\n"
                
                if len(warning_checks) > 3:
                    findings += f"- ... and {len(warning_checks) - 3} more warnings\n"
                
                findings += "\n"
            
            if passed_checks:
                findings += f"✅ {len(passed_checks)} checks passed\n\n"
        
        return findings
    
    def _generate_recommendations_section(self, results: Dict[str, Any]) -> str:
        """Generate recommendations section."""
        if not results["recommendations"]:
            return "🎉 **No immediate actions required!** Your repository is in excellent health."
        
        recs = "### Priority Actions\n\n"
        
        # Sort by priority
        priority_order = {"critical": 0, "high": 1, "medium": 2, "low": 3}
        sorted_recs = sorted(
            results["recommendations"], 
            key=lambda x: priority_order.get(x["priority"], 4)
        )
        
        for rec in sorted_recs:
            priority_emoji = {
                "critical": "🚨",
                "high": "🔥", 
                "medium": "📋",
                "low": "💡"
            }.get(rec["priority"], "📝")
            
            recs += f"{priority_emoji} **{rec['title']}** ({rec['priority']} priority)\n"
            recs += f"   {rec['description']}\n"
            recs += f"   *Action:* {rec['action']}\n\n"
        
        return recs
    
    def _generate_metrics_table(self, results: Dict[str, Any]) -> str:
        """Generate metrics summary table."""
        table = "| Category | Total Checks | Passed | Failed | Warnings |\n"
        table += "|----------|--------------|--------|--------|---------|\n"
        
        for category, stats in results["summary"].items():
            table += f"| {category.title()} | {stats['total']} | {stats['passed']} | {stats['failed']} | {stats['warnings']} |\n"
        
        total_checks = sum(s['total'] for s in results['summary'].values())
        total_passed = sum(s['passed'] for s in results['summary'].values())
        total_failed = sum(s['failed'] for s in results['summary'].values())
        total_warnings = sum(s['warnings'] for s in results['summary'].values())
        
        table += f"| **Total** | **{total_checks}** | **{total_passed}** | **{total_failed}** | **{total_warnings}** |\n"
        
        return table
    
    def _get_timestamp(self) -> str:
        """Get current timestamp."""
        from datetime import datetime
        return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

async def main():
    """CLI entry point."""
    parser = argparse.ArgumentParser(description="Generate repository health report")
    parser.add_argument("--repo-path", required=True, help="Path to repository")
    parser.add_argument("--repo-url", help="GitHub repository URL (for remote analysis)")
    parser.add_argument("--output", "-o", help="Output file path")
    parser.add_argument("--format", choices=["markdown", "json"], default="markdown",
                       help="Output format")
    
    args = parser.parse_args()
    
    if args.repo_url and not args.repo_path:
        print("Error: --repo-path is required. Remote URL analysis not yet implemented.")
        return 1
    
    repo_path = Path(args.repo_path)
    if not repo_path.exists():
        print(f"Error: Repository path {repo_path} does not exist")
        return 1
    
    try:
        generator = HealthReportGenerator()
        
        if args.format == "json":
            # Just run analysis and output JSON
            analyzer = RepositoryAnalyzer(repo_path)
            results = await analyzer.analyze()
            output = json.dumps(results, indent=2)
        else:
            # Generate markdown report
            output = await generator.generate_report(str(repo_path), args.format)
        
        if args.output:
            Path(args.output).write_text(output)
            print(f"Health report written to {args.output}")
        else:
            print(output)
        
        return 0
        
    except Exception as e:
        logger.error(f"Failed to generate health report: {e}")
        return 1

if __name__ == "__main__":
    sys.exit(asyncio.run(main()))